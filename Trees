# Tree manipulation and traveral implementations
==================================================
1) Invert Binary Tree
Given the root of a binary tree, invert the tree, and return its root.
----------------------------------------------------------------------
Python Implementation
----------------------
 class TreeNode(object):
     def __init__(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right

class Solution(object):
    def invertTree(self, root):
        if not root:
            return
        # exchange the children
        temp = root.left
        root.left = root.right
        root.right = temp

        self.invertTree(root.left)
        self.invertTree(root.right)
-----------------------------------------------------
C++ Implementation
-------------------
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
    	TreeNode* temp = NULL;
    	if(!root){
    		return NULL;
    	}
    	
    	// exchange children
    	temp = root->left;
    	root->left = root->right;
    	root->right = temp;

    	invertTree(root->left);
    	invertTree(root->right);
    	
    	return root;
    }
};
==============================================================================================
2) Same Tree
Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
-----------------------------------------------------------------------------------------------------------
Python Implementation
---------------------
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSameTree(self, p, q):
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        return (self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right))
 
 C++ Implementation
 ------------------
 class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p and !q){
        	return true;
        }
        if(!p or !q or (p->val != q->val)){
        	return false;
        }
        return (isSameTree(p->left, q->left) and isSameTree(p->right, q->right));
    }
};
==========================================================================================
3) Subtree of Another Tree
Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree 
of itself.
-------------------------------------------------------------------------------------------------------------------

Python Implementation
---------------------
class TreeNode(object):
    self.val = val
    self.left = left
    self.right = right

class Solution(object):
    def isSubtree(self, root, subRoot):
        # if the node is empty
        if not root:
            print("not root")
            return False
        if root.val == subRoot.val and self.compareTree(root,subRoot):
            return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)


    def compareTree(self, root1, root2):
            # if both nodes dont exist then still congruent
            if not root1 and not root2:
                print("root1 but not root2")
                return True
            # if one node exists and the other doesnt
            if (root1 and not root2) or (root2 and not root1):
                print("one node exists and the other doesnt")
                return False
            if root1.val != root2.val:
                print("root1.val != root2.val")
                return False
            # if further left node and right nodes match
            return self.compareTree(root1.left, root2.left) and self.compareTree(root1.right, root2.right)

